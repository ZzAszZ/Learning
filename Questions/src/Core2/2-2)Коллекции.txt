1.Что такое «коллекция»?
    «Коллекция» - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть числа,
    строки, объекты пользовательских классов и т.п.

    На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map.
    Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных:
    простые последовательные наборы элементов и наборы пар «ключ — значение» соответственно.

    Интерфейс Collection расширяют интерфейсы:

    List (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Реализации:
    ArrayList - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых
    элементов. Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу.
    LinkedList (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как собственно данные,
    так и две ссылки на следующий и предыдущий узел.
    Vector — реализация динамического массива объектов, методы которой синхронизированы.
    Stack — реализация стека LIFO (last-in-first-out).
    Set (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:
    HashSet - использует HashMap для хранения данных. В качестве ключа и значения используется добавляемый элемент.
     Из-за особенностей реализации порядок элементов не гарантируется при добавлении.
    LinkedHashSet — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов.
    TreeSet — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator,
    либо сохраняет элементы с использованием «natural ordering».
    Queue (очередь) предназначена для хранения элементов с предопределённым способом вставки и
    извлечения FIFO (first-in-first-out):
    PriorityQueue — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator,
    либо сохраняет элементы с использованием «natural ordering».
    ArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать
    конструкцию вида LIFO (last-in-first-out).


    Интерфейс Map реализован классами:

    Hashtable — хэш-таблица, методы которой синхронизированы. Не позволяет использовать null в качестве значения или
    ключа и не является упорядоченной.
    HashMap — хэш-таблица. Позволяет использовать null в качестве значения или ключа и не является упорядоченной.
    LinkedHashMap — упорядоченная реализация хэш-таблицы.
    TreeMap — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность
    управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием
    «natural ordering».
    WeakHashMap — реализация хэш-таблицы, которая организована с использованием weak references для ключей (сборщик
    мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента
    нет жёстких ссылок).

2.Расскажите про иерархию коллекций
картинка коллекции

3.Почему Map — это не Collection, в то время как List и Set являются Collection?
    Collection представляет собой совокупность некоторых элементов. Map - это совокупность пар «ключ-значение».

4.В чем разница между классами java.util.Collection и java.util.Collections?
    java.util.Collections - набор статических методов для работы с коллекциями.

    java.util.Collection - один из основных интерфейсов Java Collections Framework.

5.Какая разница между итераторами с fail-fast и fail-safe поведением? (С примерами)
    fail-fast поведение означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система
    немедленно прекращает дальнейшую работу и уведомляет об этом. Использование fail-fast подхода позволяет избежать
    недетерминированного поведения программы в течение времени.

    В Java Collections API некоторые итераторы ведут себя как fail-fast и выбрасывают ConcurrentModificationException,
    если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент напрямую из
    коллекции, а не используя методы итератора.

    Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):

    при изменении коллекции счетчик модификаций так же изменяется;
    при создании итератора ему передается текущее значение счетчика;
    при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.
    к оглавлению

    В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому
    что они работают с клоном коллекции вместо оригинала.

    Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap являются
    примерами итераторов fail-safe.

6.Чем различаются Enumeration и Iterator?
    Хотя оба интерфейса и предназначены для обхода коллекций между ними имеются существенные различия:

    с помощью Enumeration нельзя добавлять/удалять элементы;

    в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует
    Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);

    Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных
    классах-коллекциях.

7.Как между собой связаны Iterable, Iterator и «for-each»?

Интерфейс Iterable имеет только один метод - iterator(), который возвращает Iterator.

8.Можно ли итерируясь по ArrayList удалить элемент? Какое вылетит исключение?
    Подвох в том, что итератор ArrayList, который используется в таком варианте цикла for, является fail-fast,
    то есть не поддерживает итерацию с параллельной модификацией. А параллельная модификация случается даже в
    одном потоке, что демонстрирует этот пример. Следующий шаг итератора после удаления элемента выбросит
    ConcurrentModificationException.

    Не исключение, но неожиданный результат получится если пользоваться не итератором, а обычным циклом for –
    при каждом удалении нумерация элементов будет сдвигаться.

    Единственный способ удалить элемент из коллекции при обходе, не получив при этом ConcurrentModificationException
     или неопределенное поведение – удалить с помощью remove() того же инстанса итератора. Вариант ListIterator поможет,
     если в теле цикла требуется и работа с индексами.

    Некоторые коллекции, такие как CopyOnWriteArrayList и ConcurrentHashMap адаптированные под многопоточную среду и
    имеют fail-safe итераторы.


9.Как поведёт себя коллекция, если вызвать iterator.remove()?
    При следующем вызове методов итератора будет выброшено ConcurrentModificationException.

10.Чем Set отличается от List?
    Set — это неупорядоченное множество уникальных элементов.
    Например, мешочек с бочонками для игры в лото: каждый номер от 1 до 90 встречается в нём ровно один раз, и
    заранее неизвестно, в каком порядке бочонки вынут при игре.

    List — упорядоченный список, в котором у каждого элемента есть индекс. Дубликаты значений допускаются.
    Например, последовательность букв в слове: буквы могут повторяться, при этом их порядок важен.

11.Расскажите про интерфейс Set.
    Set - это интерфейс в Java коллекции (Java Collection Framework) и является подинтерфейсом Collection,
    поэтому он обладает всеми функциями Collection. Set - это неупорядоченная Collection (unordered Collection),
    не допускающая дублирования элементов и содержащая максимум 1 null-элемент.

12.Расскажите про реализации интерфейса Set
    HashSet – это коллекция, которая для хранения элементов внутри использует их хэш-значения, которые возвращает метод hashCode().

    LinkedHashSet – это HashSet, в котором элементы хранятся еще и в связном списке. Обычный HashSet не поддерживает
    порядок элементов. Во-первых, официально его просто нет, во-вторых, даже внутренний порядок может сильно поменяться
    при добавлении всего одного элемента.

    — TreeSet – это коллекция, которая хранит элементы в виде упорядоченного по значениям дерева. Внутри TreeSet<E>
    содержится TreeMap<E, Object> который и хранит все эти значения. А этот TreeMap использует красно—черное
    сбалансированное бинарное дерево для хранения элементов. Поэтому у него очень быстрые операции add, remove, contains.


13.В чем отличия TreeSet и HashSet?
    HashSet хранит элементы в произвольном порядке, но зато быстро ищет. Подходит,
    если порядок Вам не важен, но важна скорость. Более того, для оптимизации поиска, HashSet будет хранить элементы так, как ему удобно.

    LinkedHashSet будет хранить элементы в порядке добавления, но зато работает медленнее.

    TreeSet хранит элементы отсортированными.


15.Что будет, если добавлять элементы в TreeSet по возрастанию?
        На самом, деле, как выше упоминалось в основе TreeSet лежит красно-черное дерево, которое умеет само себя
        балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы,
        преимущества этой структуры данных будут сохраняться.

16.Как устроен HashSet, сложность основных операций.

17.Как устроен LinkedHashSet, сложность основных операций.

18.Как устроен TreeSet, сложность основных операций.

19.Расскажите про интерфейс List

20.Как устроен ArrayList, сложность основных операций.

21.Как устроен LinkedList, сложность основных операций.

22.Почему LinkedList реализует и List, и Deque?

23.Чем отличаются ArrayList и LinkedList?
    ArrayList это список, реализованный на основе массива, а LinkedList — это классический двусвязный список,
    основанный на объектах с ссылками между ними.

    ArrayList:

    доступ к произвольному элементу по индексу за константное время O(1);
    доступ к элементам по значению за линейное время O(N);
    вставка в конец в среднем производится за константное время O(1);
    удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся
    «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
    вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся
    «правее» смещаются на одну ячейку вправо;
    минимум накладных расходов при хранении.
    LinkedList:

    на получение элемента по индексу или значению потребуется линейное время O(N);
    но доступ к первому и последнему элементу списка всегда осуществляется за константное время O(1)
    — ссылки постоянно хранятся на первый и последний элемент;
    на добавление и удаление в начало или конец списка потребуется константное O(1);
    вставка или удаление в/из произвольного место константное O(1);
    но поиск позиции вставки и удаления за линейное время O(N);
    требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся
    еще указатели на следующий и предыдущий элементы списка.
    В целом, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти, и по скорости
    выполнения операций. LinkedList предпочтительно применять, когда нужны частые операции вставки/удаления или в
    случаях, когда необходимо гарантированное время добавления элемента в список.

24.Что такое Queue?
    Queue - это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) -
    соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди.
    Хотя этот принцип нарушает, к примеру, PriorityQueue, использующая «natural ordering» или переданный Comparator
    при вставке нового элемента.

25.Что такое Dequeue? Чем отличается от Queue?
    Deque (Double Ended Queue) расширяет Queue и согласно документации, это линейная коллекция,
    поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого, реализации интерфейса Deque могут
    строится по принципу FIFO, либо LIFO.

    Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), вместо этого используются
    унаследованные методы класса Object, основанные на сравнении ссылок.

26.Приведите пример реализации Dequeue.

27.Какая коллекция реализует FIFO?

28.Какая коллекция реализует LIFO?

29.Оцените количество памяти на хранение одного примитива типа byte в LinkedList?

30.Оцените количество памяти на хранение одного примитива типа byte в ArrayList?

31.Какие существуют реализации Map?
    Наиболее известные реализации java.util.Map:

    java.util.HashMap - основана на хэш-таблицах.
    java.util.LinkedHashMap - расширение предыдущей реализации на основе двусвязных списков.
    java.util.TreeMap - основана на красно-черном дереве.

    Структура данных	Производительность (basic ops)	Память	                    Отсортированность элементов	Работа с null
    Treemap	            O(log(N))	                Без издержек	                В естественном порядке	Недопустимы null ключи, без ограничений на null значения
    HashMap	            O(1)	                    С издержками	                Неотсортирован	Допустим null ключ, без ограничений на null значения
    Linked HashMap	    O(1)                        (но медленнее HashMap)	        В порядке добавления Допустим null ключ, без ограничений на null значения
                                                    Также как и в HashMap

32.Как устроена HashMap, сложность основных операций? (Расскажите про принцип корзин)

33.Что такое LinkedHashMap?
    Из названия можно догадаться что данная структура является симбиозом связанных списков и хэш-мапов. Действительно,
    LinkedHashMap расширяет класс HashMap и реализует интерфейс Map, но что же в нем такого от связанных списков?
    Давайте будем разбираться.

34.Как устроена TreeMap, сложность основных операций?

35.Что такое WeakHashMap?
    WeakHashMap - это класс, аналогичный классу HashMap, все они используют метод хеширования (hashing technique) для
    хранения и извлечения данных. Разница в том, что если объект указан в качестве ключа of WeakHashMap, он может быть
    удален из памяти Garbage Collector (GC) (сборщиком мусора), если он больше не используется в другом месте,
    более сильном, чем GC.

36.Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?

    Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.

37.Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?

38.Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?

39.Почему нельзя использовать byte[] в качестве ключа в HashMap?

40.Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?

41.Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?

42.Какое худшее время работы метода get(key) для ключа, который есть в HashMap?