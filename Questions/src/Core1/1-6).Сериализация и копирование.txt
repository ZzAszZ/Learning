Сериализация и копирование

1.Что такое сериализация и как она реализована в Java?
    Сериализация — это процесс преобразования объекта в поток байтов для сохранения или передачи в память, базу данных
    или файл. Эта операция предназначена для того, чтобы сохранить состояния объекта для последующего воссоздания при
    необходимости.

    Сериализуемый в Java является интерфейсом маркера и не имеет полей или методов для реализации.
    Это похоже на процесс регистрации, с помощью которого мы делаем наши классы сериализуемыми.
    Сериализация в java реализована ObjectInputStream и ObjectOutputStream, поэтому все, что нам нужно, –
    это обернуть их, чтобы либо сохранить в файл, либо отправить по сети.

2.Для чего нужна сериализация?
    Сериализация — это процесс преобразования объекта в поток байтов для сохранения или передачи в память,
    базу данных или файл. Эта операция предназначена для того, чтобы сохранить состояния объекта для
    последующего воссоздания при необходимости. Обратный процесс называется десериализацией.

3.Опишите процесс сериализации/десериализации с использованием Serializable.

    При использовании Serializable применяется алгоритм сериализации, который с помощью рефлексии (Reflection API) выполняет:

    запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID,
    идентификаторы полей класса);
    рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно);
    запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
    рекурсивную запись объектов, которые являются полями сериализуемого объекта.
    При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с
    циклическими ссылками.

    Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока.
    Конструктор объекта при этом не вызывается. Однако при десериализации будет вызван конструктор без параметров
    родительского несериализуемого класса, а его отсутствие повлечёт ошибку десериализации.

4.Как изменить стандартное поведение сериализации/десериализации?
    Реализовать интерфейс java.io.Externalizable, который позволяет применение пользовательской логики сериализации.
    Способ сериализации и десериализации описывается в методах writeExternal() и readExternal().
    Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal.
    Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его,
    а не метод по умолчанию :
    writeObject() - запись объекта в поток;
    readObject() - чтение объекта из потока;
    writeReplace() - позволяет заменить себя экземпляром другого класса перед записью;
    readResolve() - позволяет заменить на себя другой объект после чтения.

5.Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?
    Для управления сериализацией при определении полей можно использовать ключевое слово transient,
    таким образом исключив поля из общего процесса сериализации.

    Разумеется, при реализации Externalizable сериализовать и десериализовать это поле никто не мешает, однако я крайне
    не рекомендую этого делать, т.к. это может привести к трудноуловимым ошибкам. Поля с модификатором final
    сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable.

6.Как создать собственный протокол сериализации?
    Для создания собственного протокола сериализации достаточно реализовать интерфейс Externalizable,
    который содержит два метода:

    public void writeExternal(ObjectOutput out) throws IOException;
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;

7.Какая роль поля serialVersionUID в сериализации?
    serialVersionUID используется для указания версии сериализованных данных.

    Когда мы не объявляем serialVersionUID в нашем классе явно, среда выполнения Java делает это за нас, но этот процесс
    чувствителен ко многим метаданным класса включая количество полей, тип полей, модификаторы доступа полей,
    интерфейсов, которые реализованы в классе и пр.

    Рекомендуется явно объявлять serialVersionUID т.к. при добавлении, удалении атрибутов класса динамически
    сгенерированное значение может измениться и в момент выполнения будет выброшено исключение InvalidClassException.

8.Когда стоит изменять значение поля serialVersionUID?
    serialVersionUID нужно изменять при внесении в класс несовместимых изменений, например при удалении какого-либо его атрибута.

9.В чем проблема сериализации Singleton?
    Проблема в том что после десериализации мы получим другой объект. Таким образом, сериализация дает возможность
    создать Singleton еще раз, что не совсем не нужно. Конечно можно запретить сериализовать Singleton-ы, но это,
    фактически, уход от проблемы, а не ее решение.

10.Расскажите про клонирование объектов.
    Клонирование – это процесс копирования объекта, то есть создания нового экземпляра путем копирования самого себя.
    Клонирование в Java может быть выполнено с помощью метода clone () объекта. Клонирование создает и возвращает
    копию объекта с тем же классом и со всеми полями, имеющими одинаковые значения.

11.В чем отличие между поверхностным и глубоким клонированием?
    Различают два типа клонирования: поверхностное (shallow) и глубокое (deep). При поверхностном клонировании
    копируется сам объект. Все значимые поля клона получают значения, совпадающие со значениями полей объекта;
    все ссылочные поля клона являются ссылками на те же объекты, на которые ссылается и сам объект.
    При глубоком клонировании копируется вся совокупность объектов, связанных взаимными ссылками.

12.Какой способ клонирования предпочтительней?
    Наиболее безопасным и, следовательно, предпочтительным способом клонирования является использование
    специализированного конструктора копирования: Отсутствие ошибок наследования (не нужно беспокоиться,
    что у наследников появятся новые поля, которые не будут склонированы через метод clone()).

13.Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?
    Метод clone объявлен в классе Object а не в интерфейсе Cloneable, поэтому Cloneable не может
    функционировать как интерфейс, потому что ему не хватает общедоступного метода clone.

14.Как создать глубокую копию объекта? (2 способа)
    Конструктор клонирования.
    Срериализация
    Джейсон
    Гсон
