    1.Какие виды классов есть в java?

    2.Расскажите про вложенные классы. В каких случаях они применяются?

    - Что такое «локальный класс»? Каковы его особенности?

    3.Что такое «анонимные классы»? Где они применяются?

    - Каким образом из вложенного класса получить доступ к полю внешнего класса?

    4.Что такое перечисления (enum)?

    5.Как проблема ромбовидного наследования решена в java?

    6.Что такое конструктор по умолчанию?

    7.Могут ли быть приватные конструкторы? Для чего они нужны?

    8.Расскажите про классы-загрузчики и про динамическую загрузку классов.

    9.Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?

    10.Какие модификаторы доступа есть в Java? Какие применимы к классам?

    11.Что означает модификатор static?

    12.Может ли статический метод быть переопределён или перегружен?
    перегружен да переопределен нет.

    13.Могут ли нестатические методы перегрузить статические?

    14.Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?

    15.Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?

    16.Могут ли классы быть статическими?

    17.Что означает модификатор final? К чему он может быть применим?

    18.Что такое абстрактные классы? Чем они отличаются от обычных?

    19.Может ли быть абстрактный класс без абстрактных методов?

    20.Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?

    21.Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?

    22.Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?

    23.Может ли один интерфейс наследоваться от другого? От двух других?

    24.Что такое дефолтные методы интерфейсов? Для чего они нужны?

    25.Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?

    26.Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?

    27.Зачем нужны и какие бывают блоки инициализации?

    28.Для чего в Java используются статические блоки инициализации?

    29.Что произойдет, если в блоке инициализации возникнет исключительная ситуация?

    30.Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?

    31.Что такое класс Object?

    32.Какие методы есть у класса Object (перечислить все)? Что они делают?

    33.Расскажите про equals и hashcode

    34.Каким образом реализованы методы hashCode() и equals() в классе Object?

    35.Зачем нужен equals(). Чем он отличается от операции ==?

    36.Правила переопределения equals()

    37.Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?
        Что поменяется: процесс сравнения объектов станет намного медленней и неэффективным. При сравнении элементов в
        1ую очередь сравнивается их hash (это очень быстро, просто сравнить два числа), и только в случае равенства
        хэшей запускается метод equals (он намного медленней, но если хэш функция нормально прописана - то запуск equals
        при неравенстве объектов - крайне редкое явление - называется "коллизия").

        Некоторые коллекции используют хэширование при поиске и сравнении (HashMap, HashSet). И если, допустим имеется
        класс Car и HashMap, в котором ключ это объект класса Car, в котором не переопределен метод ХэшКод.
        Вы не сможете нормально искать объекты в коллекции. Метод contains вам будет возвращать false при поиске объекта.

    38.Какой контракт между hashCode() и equals()?

    39.Для чего нужен метод hashCode()?

    - Правила переопределения метода hashcode().

    - Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?

    40.Могут ли у разных объектов быть одинаковые hashCode()?

    41.Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?

    42.Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?

    43.Чем a.getClass().equals(A.class) отличается от a instanceOf A.class
