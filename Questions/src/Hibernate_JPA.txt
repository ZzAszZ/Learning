                                JPA и Hibernate
1.  Что такое ORM? Что такое JPA? Что такое Hibernate?
    Object-relational mapping (ORM) - это способ (он же шаблон проектирования) доступа к
    реляционной базе данных с помощью объектно-ориентированного языка

    JPA (Java Persistence API) это спецификация Java EE и Java SE,
    описывающая систему управления сохранением java объектов в таблицы реляционных баз данных в удобном виде.

    Hibernate одна из самых популярных открытых реализаций спецификации.
    То есть JPA только описывает правила и API, а Hibernate реализует эти описания,
    впрочем у Hibernate (как и у многих других реализаций JPA) есть дополнительные возможности,
    не описанные в JPA (и не переносимые на другие реализации JPA).



2.  Что такое EntityManager? Какие функции он выполняет?
        EntityManager это интерфейс, который описывает API для всех основных операций над Entity, получение данных и
        других сущностей JPA. По сути главный API для работы с JPA. Основные операции:
        1) Для операций над Entity: persist (добавление Entity под управление JPA), merge (обновление),
        remove (удаления), refresh (обновление данных), detach (удаление из управление JPA),
        lock (блокирование Enity от изменений в других thread),
        2) Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery,
        contains, createNamedStoredProcedureQuery, createStoredProcedureQuery
        3) Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder,
        getMetamodel, getDelegate
        4) Работа с EntityGraph: createEntityGraph, getEntityGraph
        5) Общие операции над EntityManager или всеми Entities: close, isOpen, getProperties, setProperty, clear



3.  Каким условиям должен удовлетворять класс чтобы являться Entity?

    1) Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA,
    2) Entity класс должен содержать public или protected конструктор без аргументов
    (он также может иметь конструкторы с аргументами),
    3) Entity класс должен быть классом верхнего уровня (top-level class),
    4) Entity класс не может быть enum или интерфейсом,
    5) Entity класс не может быть финальным классом (final class),
    6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге
    (persistent final methods or persistent final instance variables),
    7) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object),
    например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс,
    8) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны
    быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к
    методам (getter/setter методам или другим методам бизнес-логики в Entity классе),
    9) Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально
    определяют запись этого Enity класса в базе данных,


4.  Может ли абстрактный класс быть Entity?

    — да, абстрактный класс может быть сущностью и может быть аннотирован с помощью @Entity.

5.  Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?

    Может наследоваться и от других Entity классов, и от не Entity классов. Состояние (поля) не Entity суперкласса не
    является персистентным, то есть не хранится в БД и не обрабатывается провайдером (Hibernate), поэтому любое такое
    состояние (поля), унаследованное Entity классом, также не будет отображаться в БД.


7.  Может ли не Entity класс наследоваться от Entity класса?

    Да

8.  Что такое встраиваемый (Embeddable) класс?  Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?

    Встраиваемый (Embeddable) класс это класс который не используется сам по себе, только как часть одного или
    нескольких Entity классов. Entity класс могут содержать как одиночные встраиваемые классы, так и коллекции
    таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения
    каждый встраиваемый класс принадлежит только одному объекту Entity класса и не может быть использован для передачи
    данных между объектами Entity классов (то есть такой класс не является общей структурой данных для разных объектов).
    В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity, можно
    считать что JPA просто встраивает в Entity вместо объекта такого класса те атрибуты, которые он содержит.


    1. Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны
    содержать первичный ключ и быть отмечены аннотацией Entity (см. вопрос 10),

    2. Embeddable класс должен быть отмечен аннотацией Embeddable или описан в XML файле конфигурации JPA,


9.  Что такое Mapped Superclass?

    Mapped Superclass это класс от которого наследуются Entity, он может содержать аннотации JPA, однако сам такой класс
    не является Entity, ему не обязательно выполнять все требования установленные для Entity (например, он может не
    содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query.


10. Какие три типы стратегии наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?

    Всего таких стратегий 4:

    ТАблеТу Класс
    1) Использовать одну таблицу для каждого класса и полиморфное поведение по умолчанию.


    2) Одна таблица для каждого конкретного класса, с полным исключением полиморфизма и отношений наследования из
    схемы SQL (для полиморфного поведения во время выполнения будут использоваться UNION-запросы)

    3) Единая таблица для всей иерархии классов. Возможна только за счет денормализации схемы SQL. Определять
    суперкласс и подклассы будет возможно посредством различия строк.

    4) Одна таблица для каждого подкласса, где отношение “is a” представлено в виде «has a»,
    т.е. – связь по внешнему ключу с использованием JOIN.


11. Как мапятся Enumы?

    Как видите для того чтобы добавить Enum в Entity нам потребовалось просто проаннотировать атрибут
    enum аннотацией @Enumerated


12. Как мапятся даты (до java 8 и после)?
    java.sql Hibernate позволяет отображать различные классы даты/времени из Java в таблицах баз данных. Стандарт SQL определяет три типа даты/времени:

    DATE - Представляет календарную дату путем хранения лет, месяцев и дней. Эквивалентом JDBC является java.sql.Date.
    TIME - Представляет время дня и хранит часы, минуты и секунды. Эквивалентом JDBC является java.sql.Time.
    TIMESTAMP - Хранит как DATE, так и TIME плюс наносекунды. Эквивалентом JDBC является java.sql.Timestamp.
    Поскольку эти типы соответствуют SQL, их сопоставление относительно простое. Мы можем использовать аннотацию @Basic или @Column:


    java.util.Date Тип java.util.Date содержит информацию о дате и времени с точностью до миллисекунд.
    Но так как классы из этого пакета не имели прямого соответствия типам данных SQL, приходилось использовать
    над полями java.util.Date аннотацию @Temporal, чтобы дать понять SQL, с каким конкретно типом данных она работает.
    Для этого у аннотации @Temporal нужно было указать параметр TemporalType, который принимал одно из трёх значений:
    DATE, TIME или TIMESTAMP, что позволяло указать базе данных с какими конкретными типами данных она работает.



    java.time Начиная с Java 8, доступен новый API даты и времени для работы с временными значениями.
    Этот API-интерфейс устраняет многие проблемы классов java.util.Date и java.util.Calendar.
    Все классы в новом API неизменяемые (immutable) и, как следствие, потоко-безопасные.
    Точность представления времени составляет одну наносекунду, что в миллион раз точнее чем в пакете java.util.
    ипы данных из пакета java.time напрямую отображаются (маппятся) на соответствующие типы SQL. Поэтому нет
    необходимости явно указывать аннотацию @Temporal:

    LocalDate соответствует DATE.
    LocalTime и OffsetTime соответствуют TIME.
    Instant, LocalDateTime, OffsetDateTime и ZonedDateTime соответствуют TIMESTAMP.


13. Как “смапить” коллекцию примитивов?
     случае коллекции примитивов и прочих не Entity используется @Element collection, которая создаёт в
     БД отдельную таблицу с записями коллекции.

14. Какие есть виды связей?
    1.Многие ко многим.
    2.Один ко многим.
        с обязательной связью;
        с необязательной связью;
    3.Один к одному.
        с обязательной связью;
        с необязательной связью;


15. Что такое владелец связи?
    В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть,
    если это однонаправленные отношения.


16. Что такое каскады?

    Отношения сущностей часто зависят от существования другой сущности, например, отношения Человек–адрес.
    Без Person объект Address не имеет собственного значения. Когда мы удаляем объект Person, наш объект Address
    также должен быть удален.

    Каскадирование - это способ достичь этого. Когда мы выполняем какое-либо действие над целевой сущностью,
    то же самое действие будет применено к связанной сущности.

    CascadeType.ALL
    CascadeType.PERSIST
    CascadeType.MERGE
    CascadeType.REMOVE
    CascadeType.REFRESH
    CascadeType.DETACH


17. Какие два типа fetch стратегии в JPA вы знаете?
    В JPA описаны два типа fetch стратегии:
    1) LAZY — данные поля будут загруженны только во время первого доступа к этому полю,
    2) EAGER — данные поля будут загруженны немедленно.

18. Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?
    У Entity объекта существует четыре статуса жизненного цикла:
    new, managed, detached, или removed. Их описание
    1) new — объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных,
    2) managed — объект создан, управляется JPA, имеет сгенерированные первичные ключи,
    3) detached — объект был создан, но не управляется (или больше не управляется) JPA,
    4) removed — объект создан, управляется JPA, но будет удален после commit'a транзакции.

19. Как влияет операция persist на Entity объекты каждого из четырех статусов?

    1) Если статус Entity new, то он меняется на managed и объект будет сохранен в базу при commit’е транзакции или в
     результате flush операций,
    2) Если статус уже managed, операция игнорируется, однако зависимые Entity могут поменять статус на managed, если
    у них есть аннотации каскадных изменений,
    3) Если статус removed, то он меняется на managed,
    4) Если статус detached, будет выкинут exception сразу или на этапе commit’а транзакции.

20. Как влияет операция remove на Entity объекты каждого из четырех статусов?
    1) Если статус Entity new, операция игнорируется, однако зависимые Entity могут поменять статус на removed,
    если у них есть аннотации каскадных изменений и они имели статус managed,
    2) Если статус managed, то статус меняется на removed и запись объект в базе данных будет удалена при commit’е
    транзакции (так же произойдут операции remove для всех каскадно зависимых объектов),
    3) Если статус removed, то операция игнорируется,
    4) Если статус detached, будет выкинут exception сразу или на этапе commit’а транзакции.

22. Как влияет операция merge на Entity объекты каждого из четырех статусов?
     1) Если статус detached, то либо данные будет скопированы в существующей managed entity с тем же первичным ключом,
     либо создан новый managed в который скопируются данные,
     1) Если статус Entity new, то будет создана новый managed entity, в который будут скопированы данные прошлого объекта,
     2) Если статус managed, операция игнорируется, однако операция merge сработает на каскадно зависимые Entity,
     если их статус не managed,
     3) Если статус removed, будет выкинут exception сразу или на этапе commit’а транзакции.


23. Как влияет операция refresh на Entity объекты каждого из четырех статусов?
        1) Если статус Entity managed, то в результате операции будут востановленны все изменения из базы данных
        данного Entity, так же произойдет refresh всех каскадно зависимых объектов,
        2) Если статус new, removed или detached, будет выкинут exception.

24. Как влияет операция detach на Entity объекты каждого из четырех статусов?
        1) Если статус Entity managed или removed, то в результате операции статус Entity (и всех каскадно-зависимых объектов) станет detached.
        2) Если статус new или detached, то операция игнорируется.

25. Для чего нужна аннотация Basic?
    Basic — указывает на простейший тип маппинга данных на колонку таблицы базы данных.
    Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет.

26. Для чего нужна аннотация Column?
    @Column — аннотация используется для указания соответствия между атрибутом базовой сущности Entity
    класса и столбцом таблицы базы данных.

27. Для чего нужна аннотация Access?
    @Access нужна для определения типа доступа (access type) для класса entity, суперкласса,
    embeddable или отдельных атрибутов, то есть как JPA будет обращаться к атрибутам entity,
    как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сетеры (setter).
    Если вы хотите, чтобы ваши поля были доступны как обычные поля, но есть одно поле, для доступа к
    которому вы хотите использовать геттер или сеттер, вы можете предоставить аннотацию @Access.
    Эта аннотация имеет два режима: AccessType.FIELD и AccessType.PROPERTY. Мы можем явно указать тип доступа,
    используя AccessType.PROPERTY или AccessType.FIELD в @Access аннотации. Мы можем использовать @Access на уровне
    класса, поля или метода. Мы можем даже смешивать два типа в одном классе сущностей.

28. Для чего нужна аннотация Cacheable?

    @Cacheable — аннотация используется для определения хранения объекта в кэше второго уровня в зависимости от
    установленного свойства [shared-cache-mode] в файле persistence.xml. При значении [shared-cache-mode] -
    ENABLE SELECTIVE - в кэше второго уровня будут храниться только объекты помеченные аннотацией @Cacheable.

29. Для чего нужны аннотации @Embedded и @Embeddable?
    @Embeddable — аннотация используется для указания встраиваемых типов. Как и базовые типы, встраиваемые типы не
    имеют никакой идентичности, управляемой их собственностью.
    @Embedded — аннотация используется, чтобы указать,
    что данный атрибут сущности представляет встраиваемый тип.

30. Как смапить составной ключ?

        задать составной ключ с помощью аннотации @EmbeddedId.

        Класс ключа

        должен быть сериализуемым

        должен быть public и иметь public no-arg constructor (как и  сущности)

        аннотирован @Embeddable

        а также в нем должен быть переопределен equals() и hashcode()

31. Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?
        -GenerationType.TABLE -Используйте конкретную таблицу базы данных для хранения первичного ключа.
    Механизм персистентности генерирует первичный ключ через определенную таблицу в реляционной базе данных.
    Преимущество этой стратегии заключается в том, что она не зависит от внешней среды и конкретной
    реализации базы данных.
        -GenerationType.SEQUENCE

        -GenerationType.IDENTITY
    Этот вид стратегии генерации первичного ключа обычно известен как саморазвитие первичного ключа.
    Когда база данных вставляет данные, она автоматически присваивает значение первичному ключу. Например,
    YSQL может объявить «auto_increment» при создании таблицы, чтобы указать саморазвитие первичного ключа.
    Эта стратегия обеспечивает поддержку в большинстве баз данных
        -GenerationType.AUTO Стратегия генерации первичного ключа передается механизму персистентности,
     а механизм персистентности выбирает одну из трех стратегий генерации первичного ключа в соответствии с
     базой данных. Этот тип стратегии генерации первичного ключа используется чаще, так как стратегия генерации
     JPA по умолчанию - GenerationType.AUTO, при использовании этой стратегии вы можете явно указать
        @GeneratedValue (Strategy = GenerationType.AUTO) или напрямую @GeneratedValue


32. Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?
        @JoinColumn  — применяется когда внешний ключ находится в одной из сущностей. Может применяться с обеих сторон
        взаимосвязи. Но рекомендуется применять в сущности, которая является владельцем физической информации
        (обычно сторона @ManyToOne). ManyToOne (часто) является стороной-владельцем в двунаправленных связях и таким
        образом противоположная сторона использует @OneToMany(mappedBy=..).

        @JoinTable — указывает на связь с таблицей

33. Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?

    OrderBy упорядычевает результат запроса (от меньшего к большему и т.д.).

    Указывает столбец, который используется для поддержания постоянного порядка списка. @OrderColumn указывается в
    отношении OneToMany или ManyToMany или в коллекции элементов.

    @OrderColumn указывается на стороне отношения,
    ссылающейся на коллекцию, которая должна быть упорядочена. OrderColumn сохраняет порядок в List, используя
    выделенный столбец данных. Если в листе Юзеров = 1, 2, 3, 4 будет удален Юзер 3, то результат запроса будет
    1, 2, Null, 4. Т.е. порядок не нарушится.


     @OrderBy применяется только во время выполнения при получении результата запроса.
     @OrderColumn приводит к постоянному упорядочению соответствующих данных.

     @OrderBy в запросе отсортирует, а в кэше вернет неотсортированный порядок.
     @OrderedColumn сортирует данные с учетом данных в колонке, и в кеше и в запросе.



34. Для чего нужна аннотация Transient?
        @Transient — аннотация используется для указания того, что данный атрибут сущности не должен сохраняться.

        @UniqueConstraint — аннотация используется для указания уникального ограничения, которое должно быть
        включено генератором автоматической схемы для первичной или вторичной таблицы, связанной с текущим
        аннотированным объектом.



35. Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?

    У JPA есть шесть видов блокировок, перечислим их в порядке увеличения надежности (от самого ненадежного и быстрого, до самого надежного и медленного):

    1) NONE — без блокировки
    2) OPTIMISTIC (или синоним READ, оставшийся от JPA 1) — оптимистическая блокировка,
    3) OPTIMISTIC_FORCE_INCREMENT (или синоним WRITE, оставшийся от JPA 1) — оптимистическая блокировка с принудительным увеличением поля версионности,
    4) PESSIMISTIC_READ — пессимистичная блокировка на чтение,
    5) PESSIMISTIC_WRITE — пессимистичная блокировка на запись (и чтение),
    6) PESSIMISTIC_FORCE_INCREMENT — пессимистичная блокировка на запись (и чтение) с принудительным увеличением поля версионности,
    
36. Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?
        JPA говорит о двух видов кэшей (cache):
        1) first-level cache (кэш первого уровня) — кэширует данные одной сессии,
        2) second-level cache (кэш второго уровня) — кэширует данные дольше чем одна сессия. Провайдер JPA может,
        но не обязан реализовывать работу с кэшем второго уровня.

37. Как работать с кешем 2 уровня?
        В сешионфактори подключить Реджин фактору  и Дамайн Дата сторе Аксес.

38. Что такое JPQL/HQL и чем он отличается от SQL?

        Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL)
        - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL.
        JPQL - это подмножество HQL.JPQL - это язык запросов, практически такой же как SQL, однако, вместо
        имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты.

39. Что такое Criteria API и для чего он используется?
        Criteria API это тоже язык запросов, аналогичным JPQL (Java Persistence query language),
        однако запросы основаны на методах и объектах, то есть запросы выглядят так:

       CriteriaBuilder cb = ...
        CriteriaQuery<Customer> q = cb.createQuery(Customer.class);
        Root<Customer> customer = q.from(Customer.class);
        q.select(customer);

        Депликейтед.

40. Расскажите про проблему N+1 Select и путях ее решения.

        Есть User и которого есть коллекция машин Cars. Если мы хотим получить список из 10 юзеров, то в бд полетит 11
        запросов. 1 запрос на получение самих юзеров и еще 10 запросов на получение списка их машин, отдельно для
        каждого User. Это приводит к серьёзным проблемам с производительностью.

            JOIN FETCH

        Самое правильное решение - использовать JOIN FETCH и jpql на выборку сущности. Данное решение не поддерживает
        работу с нативными запросами, но работает любым видом OneToMany/ManyToOne связи. Может генерировать
        дополнительные подзапросы, тогда возможно лучше entityGraph брать, чтобы вместо подзапросов join'ы генерировались

            FetchMode.SUBSELECT

        Это Аннотация Hibernate, в JPA её нет. Можно использовать только с коллекциями. Будет сделан один sql-запрос
        для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям,
        то выполнится еще один запрос для получения связанных коллекций

            EntityGraph

        Не самое изящное решение для n+1 проблемы. Графы в основном нужны, когда требуется загрузить действительно
        большой детальный граф, т.е. когда нам нужно получить очень много связанной информации из базы, и такой большой
        запрос следует оптимизировать. Для n+1 не самое компактное решение, но тоже работает, однако такое решение не
        подойдет при использовании нативных запросов.

            Batch fetching

        Это Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой
        загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности
        будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций.


        При запросе JOIN emp.department dep возвращается только сам запрощенный объект. При запросе
        JOIN FETCH emp.department dep возвращается объект и связанные с ним сущности, в одном запросе.


41. Что такое EntityGraph? Как и для чего их использовать?
        Entity Graphs — механизм динамического изменения fetchType для каждого запроса,
