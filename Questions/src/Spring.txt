    Spring — это популярный фреймворк для разработки на Java, который используют для создания корпоративных приложений,
    например CRM. При этом применять его могут не только Java-разработчики, но и те, кто работает с Kotlin или Groovy.



    1. Что такое инверсия контроля (Ioc) и внедрение зависимостей? Как эти принципы реалезованы в Spring?
    -2. Что такое Ioc контейнер.
        Контейнеры IoC. Ключевым элементом Spring Framework является Spring Container. Container создаёт объекты,
        связывает их вместе, настраивает и управляет ими от создания до момента уничтожения. Для управления
        компонентами, из которых состоит приложение, Spring Container использует Внедрение Зависимостей (DI).

        Dependency Injection (внедрение зависимости) - это набор паттернов и принципов разработки программного
        обеспечения, которые позволяют писать слабосвязный код. В полном соответствии с принципом единой обязанности
        объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого
        общему механизму.


    -3. Что такое Bean в Spring?
        В Spring-е бином (bean) называют любой класс, который управляется контейнером Spring. То есть такими вещами,
        как создание экземпляра бина, его инициализация, внедрение зависимостей и параметров, деинициализация,
        генерация всевозможных оберток над бином, занимается не ваш код, а IoC-контейнер Spring-а.

    4. Раскажите про аннотацию @Bean.
        В классах конфигурации Spring, @Bean используется для определения компонентов с кастомной логикой.

        Эта аннотация используется на уровне метода. Метод, аннотированный этой аннотацией,
        работает как идентификатор компонента, а также создает и возвращает фактический компонент.

        @Lazy
        Эта аннотация используется для классов компонентов. По умолчанию все автосвязные зависимости создаются и
        настраиваются при запуске. Но если вы хотите лениво инициализировать бин, вы можете использовать
        @Lazy аннотацию над классом. Это означает, что bean-компонент будет создан и инициализирован только при
        первом запросе. Вы также можете использовать эту аннотацию на  @Configuration занятиях. Это указывает
        на то, что все  @Bean методы в пределах этого  @Configuration должны быть лениво инициализированы.

    5. Раскажите про аннотацию @Component.

        @Component помечает класс в качестве кандидата для создания Spring бина.

        Эта аннотация используется в классах для обозначения компонента Spring. В @Component аннотации помечает класс
        Java , как боб или компонента , так что механизм компонент сканирования весны может добавить его в контекст
        приложения.

    6. Отличия @Bean от @Component.
        @Bean используется в конфигурационных классах Spring. Он используется для непосредственного создания бина.

        @Component используется со всеми классами, которыми должен управлять Spring. Когда Spring видит класс с
        @Component, Spring определяет этот класс как кандидата для создания bean.

    7. Раскажите про аннотацию @Servise @Repository.

        @Repository — компонент, который предназначен для хранения, извлечения и поиска. Как правило, используется для
        работы с базами данных.

        ПерсистентЭксепшн. пробрасывает.

        @Service — фасад для некоторой бизнес логики

    6. Раскажите про аннотацию @Autowired.
        Можно проставить флаг Тру фалс и заисимоть не будет подтягиватся.

        @Autowired может использоваться вместе с конструкторами, сеттерами или любым другими методами.
        Когда Spring находит @Autowired на методе, Spring автоматически вызовет этот метод, после создания экземпляра бина.
        В качестве аргументов, будут подобраны подходящие объекты из контекста Spring.

        Депенсенси Инжектион.

    9. Раскажите про аннотацию @Resuorse.
        Аннотации для внедрения зависимостей.
        @Resource (java) пытается получить зависимость: по имени, по типу, затем по описанию.
        Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name.

    10. Раскажите про аннотацию @Inject.
    Аннотации для внедрения зависимостей.
        @Inject (java) или @Autowired (spring) в первую очередь пытается
        подключить зависимость по типу, затем по описанию и только потом по имени.

        Для @Inject аналог @Named, для @Autowired идет @Qulifier.


    11. Раскажите про аннотацию @LookUp.
    Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер.
    Но бывает и другая ситуация: имеется бин Car – синглтон (singleton bean), и ему требуется каждый раз новый экземпляр
    бина Passenger. То есть Car – синглтон, а Passenger – так называемый прототипный бин (prototype bean). Жизненные
    циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый – допустим,
    это происходит каждый раз при вызове какого-то метода бина Car. Вот здесь-то и пригодится внедрение бина с помощью
    Lookup-метода. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод.
    Суть в том, что мы создаём метод-заглушку в бине Car и помечаем его специальным образом – аннотацией @Lookup.
    Этот метод должен возвращать бин Passenger, каждый раз новый. Контейнер Spring под капотом создаст прокси-подкласс
     и переопределит этот метод и будет нам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного
     метода. Даже если в нашей заглушке он возвращает null (а так и надо делать - всё равно этот метод будет
     переопределен в прокси-подклассе):

    12. Можно ли вставить Bean в статическое поле.
    статические переменные загружаются до старта спринга.
        Spring не позволяет внедрять бины напрямую в статические поля, через анотации
        Чтобы исправить это, создайте нестатический сеттер-метод:

    13. Раскажите про аннотацию @Primary и @Qualifier.

        Если есть два одинаковых бина (по типу и имени) спринг не знает какой именно использовать и выдает exception.
        Если над одним из этих бинов установлена @Primary, то его использовать предпочтительнее
        (может использоваться на этапе конфигурации с соответствующими аннотациями).
        Но если нам нужно использовать в работе оба этих бина, можно над каждым поставить @Qualifier и задать имя,
        для идентификации этих бинов (работает только с @Autowired).

    14. Как заинжектить примитив.
        @Value над полем - внедряем примитив

    15. Как заинжектить коллекцию.
        Мы можем вставлять массивы примитивов и ссылочных типов. Со всеми массивами и коллекциями
        мы можем использовать внедрение через конструкторы, сеттеры или поля.




    16. Раскажите про аннотацию @Conditional.
        Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте
        только тогда, когда все условия соответствуют. Может применяться:
        ❖ над классами прямо или косвенно аннотированными @Component, включая классы
        @Configuration;
        ❖ над методами @Bean;
        ❖ как мета-аннотация при создании наших собственных аннотаций-условий.
        Условия проверяются непосредственно перед тем, как должно быть зарегистрировано

        Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации
        @ComponentScan, связанные с этим классом, также будут распространяться указанные условия.
        Для более детальной настройки классов, аннотированных @Configuration, предлагается использовать интерфейс
        ConfigurationCondition.

    17. Раскажите про аннотацию @Profile.

        нам нужно создавать определенный бин только для определенного профиля. Для этого можно аннотировать бин с помощью
        @Profile. Аннотация применима как к классу, так и к методу.


    18. Раскажите про AplicationContext и Beanfactory. В каких случаях что лучше использовать.
        ApplicationContext - это главный интерфейс в Spring-приложении, который предоставляет информацию о конфигурации
        приложения. Так же, как BeanFactory, ApplicationContext загружает бины, связывает их вместе и конфигурирует их
        определённым образом. Но кроме этого, ApplicationContext обладает дополнительной функциональностью.
        ApplicationContext предоставляет:
        Фабричные методы бина для доступа к компонентам приложения
        Возможность загружать файловые ресурсы в общем виде
        Возможность публиковать события и регистрировать обработчики на них
        Возможность работать с сообщениями с поддержкой интернационализации
        Наследование от родительского контекста

        BeanFactory - это фактический контейнер, который создает, настраивает и управляет рядом bean-компонентов.
        Эти бины обычно взаимодействуют друг с другом и, таким образом, имеют зависимости между собой.
        Эти зависимости отражены в данных конфигурации, используемых BeanFactory. BeanFactory обычно используется
        тогда, когда ресурсы ограничены (мобильные устройства). Поэтому, если ресурсы не сильно ограничены, то лучше
        использовать ApplicationContext.



    19. Раскажите про жизненный цикл Bean и анотациии @PostConstruct and @Predestroy.


        @PreDestroy
        Метод, аннотированный @PreDestroy, запускается только один раз, непосредственно перед тем, как
        Spring удаляет наш компонент из контекста приложения.
        Как и в случае с @PostConstruct, методы, аннотированные @PreDestroy, могут иметь любой уровень доступа,
        но не могут быть статическими.

        Целью этого метода может быть освобождение ресурсов или выполнение любых других задач очистки до уничтожения бина,
        например, закрытие соединения с базой данных.

    20. Раскажите про скопы бинов. Какой скоуп используется по умолчанию. Что изменилось в спринг 5.

        В простейшем Spring-приложении всегда существует два сокоупа:
        • singleton – объект создается однажды, при последующих внедрениях переиспользуется. Полезен для большинства
        случаев: различные сервисы, объекты без состояния, неизменяемые объекты. Стоит заметить, это не класс-синглтон:
        при объявлении двух бинов одного класса их экземпляров будет два. Это скоуп по умолчанию.

        • prototype – при каждом внедрении фабрика бинов создает новый объект. Нужен для изменяемых бинов с состоянием.

        Spring Web добавляет 4 дополнительных скоупа, которые делают бин синглтоном в пределах обработки одного
        сетевого запроса (request),
        клиентской сессии (session),
        контекста сервлета (application)
        и вебсокет-сессии (websocket).

    21. Раскажите про аннотацию @ComponentScan.

        Эта аннотация используется вместе с  @Configuration аннотацией, чтобы Spring мог узнать, какие пакеты сканируются
        для аннотированных компонентов. @ComponentScan также используется для указания использования базовых пакетов
        basePackageClasses или  basePackage атрибутов для сканирования. Если конкретные пакеты не определены,
        сканирование будет выполняться из пакета класса, который объявляет эту аннотацию.

    22. Как Спринг работает с транзакциями.
        Если Spring обнаруживает аннотацию @Transactional на бине, он создаёт динамический прокси этого бина.
        Прокси имеет доступ к менеджеру транзакций и будет просить его открывать и закрывать транзакции/соединения.
        Сам менеджер транзакций будет просто управлять старым добрым соединением JDBC.

        Атрибуты Анотации транзакциию.



    23. Раскажите про аннотацию @Controller and @RestController.

        @RestController = @Controller + @ResponseBody


        @Controller помечает класс как контроллер HTTP запросов. @Controller обычно используется в сочетании с аннотацией
        @RequestMapping, используемой в методах обработки запросов.

        В Spring 4.0 была представлена аннотация @RestController. Применив ее к контроллеру автоматически добавляются
        аннотации @Controller, а также @ResponseBody применяется ко всем методам. Аннотация @ResponseBody сообщает
        контроллеру, что возвращаемый объект автоматически сериализуется в JSON и передается обратно в объект HttpResponse.



    24. Что такое View-resolver.

        Views моделируют страницы в наших приложениях и позволяют изменять и предопределять их поведение, определяя их
        как bean-компоненты. Представления (Views) отвечают за рендеринг реального HTML-интерфейса, как правило, за
        выполнение какого-либо механизма шаблонов, например Thymeleaf.

        ViewResolvers — это объекты, отвечающие за получение объектов View для конкретной операции и локали. Обычно
        контроллеры просят ViewResolvers переслать представление с определенным именем (строка, возвращаемая методом
        контроллера), а затем все средства разрешения представления в приложении выполняются в упорядоченной цепочке,
        пока один из них не сможет разрешить это представление, в каком случае объект View возвращается и ему передается
        управление для рендеризации HTML.

    25. Различия ModelMap and ModelAndView?
       - Model: это интерфейс. Он определяет держатель для атрибутов модели и в первую очередь
        предназначен для добавления атрибутов в модели.

        -ModelMap: реализация Map для использования при построении данных модели для использования с инструментами
        пользовательского интерфейса.Поддерживает цепные вызовы и генерацию атрибута модели имена.

        -ModelAndView: этот класс просто содержит оба, чтобы контроллер мог возвращать как модель, так и представление
        в одном возвращаемом значении.

    26. Патерн MVC и как он реолизован в Спринг.

        Spring Boot это просто набор классов конфигурации, которые создают нужные бины в контексте. Точно так же
        их можно создать руками, просто Boot это автоматизирует. При этом помогая решить проблему конфликтов разных
        версий компонентов.
        Чтобы ускорить процесс управления зависимостями, Spring Boot неявно упаковывает необходимые сторонние зависимости
        для каждого типа приложения на основе Spring и предоставляет их разработчику посредством так называемых
        starter-пакетов (spring-boot-starter-web, spring-boot-starter-data-jpa и т.д.)

        Аннотация @SpringBootApplication включает сканирование компонентов и авто-конфигурацию через аннотацию
        @EnableAutoConfiguration

        @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector

        EnableAutoConfigurationImportSelector загружает список конфигураций из файла META-INF/spring.factories

        Каждая конфигурация пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP etc), регистрируя
        нужные бины и используя различные условия (наличие / отсутствие бина, настройки, класса и т.п.)


    27. Раскажите про патеррн FrontController и как он реализован в спринг.
        Деспетчер сервлет.

        Шаблон проектирования front controller используется для обеспечения централизованного механизма обработки
        запросов, так что все запросы будут обрабатываться одним обработчиком. Этот обработчик может выполнять
        аутентификацию / авторизацию / протоколирование или отслеживание запроса, а затем передавать запросы
        соответствующим обработчикам. Ниже приведены сущности этого типа шаблона проектирования.


    28. Что такое АОП? И как реализовано в спринге.
        Итак, АОП — аспектно-ориентированное программирование — это парадигма, направленная на повышение модульности
        различных частей приложения за счет разделения сквозных задач. Для этого  к уже существующему коду добавляется
        дополнительного поведение, без изменений в изначальном коде.



    29. В чем раница между Filters, Listeners, Interseptors.
        Концептуально всё просто, фильтры сервлетов могут перехватывать только HTTPServlets.
        Listeners могут перехватывать специфические события. Как перехватить события которые
        относятся ни к тем не другим?


        Фильтры и перехватчики делают по сути одно и тоже: они перехватывают какое-то событие, и делают что-то до
        или после.


        Java EE использует термин Filter, Spring называет их Interceptors.


        Именно здесь AOP используется в полную силу, благодаря чему возможно перехватывание вызовов любых объектов
    30. Можно ли передать в запросе один и тотже параметр несколько раз и как ?

        Да, можно принять все значения, используя массив в методе контроллера

        public String method(@RequestParam(value="name") String[] names){
        }

    31. Как работает SpringSecurity.

        SecurityContextHolder, в нем содержится информация о текущем контексте безопасности приложения, который
        включает в себя подробную информацию о пользователе(Principal) работающем в настоящее время с приложением.
        По умолчанию SecurityContextHolder используетThreadLocal для хранения такой информации, что означает, что
        контекст безопасности всегда доступен для методов исполняющихся в том же самом потоке. Для того что бы изменить
        стратегию хранения этой информации можно воспользоваться статическим методом класса
        SecurityContextHolder.setStrategyName(String strategy). Более подробно SecurityContextHolder
        SecurityContext, содержит объект Authentication и в случае необходимости информацию системы безопасности,
        связанную с запросом от пользователя.
        Authentication представляет пользователя (Principal) с точки зрения Spring Security.
        GrantedAuthority отражает разрешения выданные пользователю в масштабе всего приложения, такие разрешения
        (как правило называются «роли»), например ROLE_ANONYMOUS, ROLE_USER, ROLE_ADMIN.
        UserDetails предоставляет необходимую информацию для построения объекта Authentication из DAO объектов
        приложения или других источников данных системы безопасности. Объект UserDetailsсодержит имя пользователя,
         пароль, флаги: isAccountNonExpired, isAccountNonLocked, isCredentialsNonExpired, isEnabled и Collection
          — прав (ролей) пользователя.
        UserDetailsService, используется чтобы создать UserDetails объект путем реализации единственного метода
        этого интерфейса

    32. Что такое SpringBoot. Какие у него преимущества. Как конфигурируется. Подробно.
        . Представляем Spring Boot

        Авторы Spring решили предоставить разработчикам некоторые утилиты, которые автоматизируют
        процедуру настройки и ускоряют процесс создания и развертывания Spring-приложений, под общим названием Spring Boot


        Spring Boot — это полезный проект, целью которого является упрощение создания приложений на основе
        Spring. Он позволяет наиболее простым способом создать web-приложение, требуя от разработчиков минимум
        усилий по его настройке и написанию кода

        Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое
        приложение. Это позволит получить универсальное решение для всех, связанных со Spring технологий, избавляя
        программиста от лишнего поиска примеров кода и загрузки из них требуемых дескрипторов зависимостей
        (пример таких дескрипторов и стартовых пакетов будет показан ниже)

        Второй превосходной возможностью Spring Boot является автоматическая конфигурация приложения


        После выбора подходящего starter-пакета, Spring Boot попытается автоматически
        настроить Spring-приложение на основе добавленных вами jar-зависимостей


        Каждое Spring Boot web-приложение включает встроенный web-сервер. Посмотрите на список контейнеров сервлетов,
        которые поддерживаются "из коробки"


        Разработчикам теперь не надо беспокоиться о настройке контейнера сервлетов и развертывании приложения на нем.
        Теперь приложение может запускаться само, как исполняемый jar-файл с использованием встроенного сервера


        Если вам нужно использовать отдельный HTTP-сервер, для этого достаточно исключить зависимости по умолчанию.
        Spring Boot предоставляет отдельные starter-пакеты для разных HTTP-серверов


    33.Новвоведения Spring 5.
        Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)
        Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)
        Поддержка HTTP/2 (TLS, Push), NIO/NIO.2, Kotlin
        Поддержка Kotlin
        Реактивность (Web on Reactive Stack)
        Null-safety аннотации(@Nullable), новая документация
        Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)
        Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)
        Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava


        Помечая @Transactional класс @Service, то все его методы станут транзакционными. Так, при вызове, например,
        метода save() произойдет примерно следующее:
        1. Вначале мы имеем:
        ❖        класс TransactionInterceptor, у которого вызывается метод invoke(...), внутри которого вызывается
        метод класса-родителя TransactionAspectSupport: invokeWithinTransaction(...), в рамках которого происходит
        магия транзакций.

        ❖        TransactionManager: решает, создавать ли новый EntityManager и/или транзакцию.

        ❖        EntityManager proxy: EntityManager - это интерфейс, и то, что внедряется в бин в слое DAO на самом
        деле не является реализацией EntityManager. В это поле внедряется EntityManager proxy, который будет
        перехватывать обращение к полю EntityManager и  делегировать выполнение  конкретному EntityManager в рантайме.
        Обычно EntityManager proxy представлен классом SharedEntityManagerInvocationHandler.


        @Autowired – автоматическое внедрение подходящего бина (если только один конструктор, можно не ставить):
        1) Контейнер определяет тип объекта для внедрения
        2) Контейнер ищет соответствующий тип бина в контексте (он же контейнер)
        3) Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он
        4) Если используется @Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять
        5) В противном случае контейнер внедрит бин, основываясь на его имени или ID
        6) Если ни один из способов не сработал, то будет выброшено исключение
            Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим,
            аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP.
        В аннотации есть один параметр required = true/false - указывает, обязательно ли делать DI.
        По умолчанию true. Либо можно не выбрасывать исключение, а оставить поле c null, если нужный бин не был найден - false.



        BeanFactory
        BeanFactory — это интерфейс, который предоставляет механизм конфигурации, способный управлять объектами любого
        типа. В общем, BeanFactory предоставляет инфраструктуру конфигурации и основные функциональные возможности.
        BeanFactory легче по сравнению с ApplicationContext.
        ApplicationContext
        ApplicationContext является наследником BeanFactory и полностью реализует его
        функционал, добавляя больше специфических enterprise-функций

        1. ApplicationContext загружает все бины при запуске, а BeanFactory - по требованию.
        2. ApplicationContext расширяет BeanFactory и предоставляет функции, которые подходят
        для корпоративных приложений:
            a. поддержка внедрения зависимостей на основе аннотаций;
            b. удобный доступ к MessageSource (для использования в интернационализации);
            c. публикация ApplicationEvent - для бинов, реализующих интерфейс  ApplicationListener, с помощью интерфейса
        ApplicationEventPublisher;
            d. простая интеграция с функциями Spring AOP.
        3. ApplicationContext поддерживает автоматическую регистрацию BeanPostProcessor и  BeanFactoryPostProcessor.
        Поэтому всегда желательно использовать ApplicationContext,  потому что Spring 2.0 (и выше) интенсивно использует
        BeanPostProcessor.
        4. ApplicationContext поддерживает практически все типы scope для бинов, а BeanFactory
        поддерживает только два - Singleton и Prototype.
        5. В BeanFactory не будут работать транзакции и Spring AOP. Это может привести к  путанице, потому что
        конфигурация с виду будет корректной.
