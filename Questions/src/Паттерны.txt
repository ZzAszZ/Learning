    1.  Что такое шаблон проектирования?

    . Шаблон проектирования или паттерн (англ. design pattern) в разработке программного обеспечения — повторяемая
    архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто
    возникающего контекста. Обычно шаблон не является законченным образцом, который может быть прямо преобразован в
    код; это лишь пример решения задачи, который можно использовать в различных ситуациях.
        Есть три основных типа шаблонов проектирования:

        • структурный
        • порождающий
        • поведенческий

        Структурные шаблоны, в общем случае, имеют дело с отношениями между объектами, облегчая их совместную работу.

        Порождающие шаблоны обеспечивают механизмы инстанцирования, облегчая создание объектов способом,
        который наиболее соответствует ситуации.

        Поведенческие шаблоны используются в коммуникации между объектами, делая её более лёгкой и гибкой.

    2.  Назовите основные характеристики шаблонов.

        -Имя - все шаблоны имеют уникальное имя, служащее для их идентификации;

        -Назначение -назначение данного шаблона;

        -Задача - задача, которую шаблон позволяет решить;

        -Способ решения - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;

        -Участники - сущности, принимающие участие в решении задачи;

        -Следствия - последствия от использования шаблона как результат действий, выполняемых в шаблоне;

        -Реализация - возможный вариант реализации шаблона.

    3.  Назовите три основные группы паттернов.

        Основные (Fundamental) - основные строительные блоки других шаблонов. Большинство других шаблонов использует
        эти шаблоны в той или иной форме.

        Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание экземпляра.
        Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон,
        порождающий классы, использует наследование, чтобы изменять созданный объект, а шаблон, порождающий объекты,
        делегирует создание объектов другому объекту.

        Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже
        существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.

        Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его
        гибкость.


    Поведенческие шаблоны проектирования.
    1.Цепочка обязанностей (Chain of responsibility) - Предназначен для организации в системе уровней ответственности.
         Одним из таких классических примеров являются фильтры сервлетов в Java, которые позволяют нескольким фильтрам
         обрабатывать HTTP-запрос. Хотя в этом случае каждый фильтр вызывает цепочку вместо следующего фильтра.

    2.Команда (Command) - Представляет действие. Объект команды заключает в себе само действие и его параметры.
        есть класс Light, который умеет две вещи: включить свет и выключить. Он в терминах паттерна будет
        "приемник команд (receiver)"

    3.Интерпретатор (Interpreter) - Решает часто встречающуюся, но подверженную изменениям, задачу.

    4.Итератор (Iterator) - Представляет собой объект, позволяющий получить последовательный доступ к элементам
    объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.

    5.Посредник (Mediator) - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и
    избавляя объекты от необходимости явно ссылаться друг на друга.

    6.Хранитель (Memento) - Позволяет, не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта так,
     тобы позднее восстановить его в этих состояниях.

    7.Наблюдатель (Observer) - Определяет зависимость типа «один ко многим» между объектами таким образом, что при
    изменении состояния одного объекта все зависящие от него оповещаются об этом событии.

    8.Состояние (State) - Используется в тех случаях, когда во время выполнения программы объект должен менять своё
    поведение в зависимости от своего состояния.

    9.Стратегия (Strategy) - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения
     их взаимозаменяемости.

    10.Шаблонный метод (Template method) - Определяет основу алгоритма и позволяет наследникам переопределять некоторые
    шаги алгоритма, не изменяя его структуру в целом.

    11.Посетитель (Visitor) - Описывает операцию, которая выполняется над объектами других классов. При изменении класса
    Visitor нет необходимости изменять обслуживаемые классы.

    Приведите примеры порождающих шаблонов проектирования.
    1.Абстрактная фабрика (Abstract factory) - Класс, который представляет собой интерфейс для создания других классов.

    2.Строитель (Builder) - Класс, который представляет собой интерфейс для создания сложного объекта.

    3.Фабричный метод (Factory method) - Делегирует создание объектов наследникам родительского класса. Это позволяет
    использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

    4.Прототип (Prototype) - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания
    через конструктор.

    5.Одиночка (Singleton) - Класс, который может иметь только один экземпляр.
        Ограничивает создание одного экземпляра класса, обеспечивает доступ к его единственному объекту.
        Конструктор класса приватный. Метод getInstance() создает только один экземпляр класса.


    Приведите примеры структурных шаблонов проектирования.
    1.Адаптер (Adapter) - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а
    другой предоставляет несовместимый с первым интерфейс.

    2.Мост (Bridge) - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.

    3.Компоновщик (Composite) - Объект, который объединяет в себе объекты, подобные ему самому.

    4.Декоратор (Decorator) - Класс, расширяющий функциональность другого класса без использования наследования.
    Защет класса оберток.

    5.Фасад (Facade) - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.

    6.Приспособленец (Flyweight) - Это объект, представляющий себя как уникальный экземпляр в разных местах программы,
    но по факту не являющийся таковым.

    7.Заместитель (Proxy) - Объект, который является посредником между двумя другими объектами, и который
    реализует/ограничивает доступ к объекту, к которому обращаются через него.
    ТРанзакшион в спринге.


    15. Патеррны в Spring.

        Proxy (Заместитель)
            Объект, который является посредником между двумя другими объектами, и который
                реализует/ограничивает доступ к объекту, к которому обращаются через него.

        Singleton (Одиночка)
                Класс, который может иметь только один экземпляр.

        Factory (Фабрика)
            Этот паттерн позволяет инициализировать объект через публичный статический метод, называемый фабричным методом.

            Spring использует паттерн Factory для создания объекта бина с использованием следующих двух подходов.

            BeanFactory

            Простой контейнер, который обеспечивает базовую поддержку DI (Dependency Injection, инъекция зависимостей).
            Для работы с этим контейнером используется интерфейс org.springframework.beans.factory.BeanFactory.

            ApplicationContext

            Другой контейнер, присутствующий в Spring, который добавляет специфичные enterprise-функции.
            Эти функции включают в себя возможность чтения параметров из property-файлов и публикацию событий
            приложения для слушателей событий.



        Template (Шаблон)

            Этот паттерн широко используется для работы с повторяющимся бойлерплейт кодом
            (таким как, закрытие соединений и т. п.). Примечание переводчика: JpaTemplate объявлен устаревшим с Spring 3.1).



        Model View Controller (Модель-Представление-Контроллер)
            Преимущество Spring MVC в том, что ваши контроллеры являются POJO, а не сервлетами. Это облегчает
            тестирование контроллеров. Стоит отметить, что от контроллеров требуется только вернуть логическое
            имя представления, а выбор представления остаётся за ViewResolver. Это облегчает повторное использование
            контроллеров при различных вариантах представления.


        Front Controller (Контроллер запросов)
            Паттерн Front Controller используется для обеспечения централизованного механизма обработки запросов,
            так что все запросы обрабатываются одним обработчиком. Этот обработчик может выполнить аутентификацию,
            авторизацию, регистрацию или отслеживание запроса, а затем передать запрос соответствующему контроллеру.


        View Helper (Вспомогательный компонент представления)
            В Spring есть несколько пользовательских JSP-тегов и макросов Velocity, помогающие отделить код от представления.


            View Helper отделяет статическое содержимое в представлении, такое как JSP, от обработки бизнес-логики.


            Фреймворки, такие как Spring и Struts, предоставляют собственные библиотеки тегов для инкапсуляции
            логики обработки в хелперах вместо размещения логики в представлении, таком как JSP-файлы.


        Dependency injection и Inversion of control (IoC) (Внедрение зависимостей и инверсия управления)

            IoC-контейнер в Spring, отвечает за создание объекта, связывание объектов вместе,
             конфигурирование объектов и обработку всего их жизненного цикла от создания до полного уничтожения.


            В контейнере Spring используется инъекция зависимостей (Dependency Injection, DI) для управления
            компонентами приложения. Эти компоненты называются "Spring-бины" (Spring Beans).


        Service Locator (Локатор служб)
            ServiceLocatorFactoryBean сохраняет информацию обо всех бинах в контексте. Когда клиентский код запрашивает
            сервис (бин) по имени, он просто находит этот компонент в контексте и возвращает его. Клиентскому коду
            не нужно писать код, связанный со Spring, чтобы найти бин.


            Паттерн Service Locator используется, когда мы хотим найти различные сервисы, используя JNDI. Учитывая
            высокую стоимость поиска сервисов в JNDI, Service Locator использует кеширование. При запросе сервиса
            первый раз Service Locator ищет его в JNDI и кэширует объект. Дальнейший поиск этого же сервиса через
            Service Locator выполняется в кэше, что значительно улучшает производительность приложения.


        Observer-Observable (Наблюдатель)
        Используется в механизме событий ApplicationContext.
        Определяет зависимость "один-ко-многим" между объектами, чтобы при изменении состояния
        одного объекта все его подписчики уведомлялись и обновлялись автоматически.


        Context Object (Контекстный объект)
        Паттерн Context Object, инкапсулирует системные данные в объекте-контексте для совместного использования
        другими частями приложения без привязки приложения к конкретному протоколу.


        ApplicationContext является центральным интерфейсом в приложении Spring для предоставления информации о
        конфигурации приложения.


        16. Патеррны в Hibernate.

            Domain Model Pattern – объектная модель предметной области, включающая в себя как поведение так и данные.

            Data Mapper – слой мапперов (Mappers), который передает данные между объектами и базой данных,
            сохраняя их независимыми друг от друга и себя.

            Proxy Pattern — применяется для ленивой загрузки.

            Factory pattern — используется в SessionFactory

