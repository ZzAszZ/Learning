                                Многопоточность
1.  Чем процесс отличается от потока?
    Процессы и потоки связаны друг с другом, но при этом имеют существенные различия.

    Процесс — экземпляр программы во время выполнения, независимый объект,
    которому выделены системные ресурсы (например, процессорное время и память).
    Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и
    структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать
    межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.

    Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные
    своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти,
    в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса.
    У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.

    Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же
    становится видно другим потокам этого процесса.

2.  Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable?(Ответ что тред - это класс,
а ранбл интерфейс - считается не полным, нужно рассказать подробно)

    Thread - это абстракция над физическим потоком.

    Runnable - это абстракция над выполняемой задачей.

    Плюс использования Runnable состоит в том, что это позволяет логически отделить выполнение задачи от логики управления потоками.


3.  Что такое монитор? Как монитор реализован в java?
    — Монитором принято называть объект, который хранит состояние занят/свободен.

    В целом, можно считать, что мютекс это частный случай семафора. Семафор работает просто - у него есть некое
    начальное число - счетчик. Каждый раз, когда какой то поток "захватывает" семафор, это число уменьшается на единицу.
     Если оно равно нулю или меньше нуля - семафор запирается (то есть, грубо говоря, код останавливается на моменте
     захвата семафора). Каждый раз, когда семафор освобождается - этот счетчик увеличивается на единицу.
     И если он после этого окажется больше нуля, то какому то произвольному потоку, который "висит на захвате семафора"
      будет послан сигнал на пробуждение и он сможет продолжить работу (естественно, снова уменьшив значение счетчика).
    Самый очевидный пример семафора - это менеджеры закачек - добавляем много файлов на закачку, но ограничиваем
    количество одновременных скачек.
    А мютекс - это просто семафор, который инициализирован начальным числом 1. Поэтому, только один поток может его
    захватить. Но как всегда, есть исключения. Есть так называемые мютексы на чтение-запись (RWLock).
    Эти мютексы можно захватывать на чтение и на запись. И если на чтение может захватить много потоков,
    то на запись - только один (да, и в этот момент больше никто не может читать).
    что мьютекс - это некий объект, который связан с каждым объектом в Джава, и который может принимать два состояния:
    занят и свободен.
    это почти близко к истине. Да, в java у класса Object есть поле типа мютекс. И все наследники
    (читай все остальные классы) также получают персональный мютекс. если метод пометить словом syncronized,
    то это просто заворачивает его вызов в этот мютекс. То есть, если вызывать syncronized методы у одного объекта с
    разных потоков - мютекс не даст им выполнятся параллельно. Но для разных объектов (даже одного типа) это уже не
    работает.

4.  Что такое синхронизация? Какие способы синхронизации существуют в java?
    Синхронизировать прикладной код можно двумя способами:
    -С помощью синхронизированных методов. Метод объявляется с использованием ключевого слова synchronized:
    Заключить вызовы методов в блок оператора synchronized:

    Только методы и блоки могут быть синхронизированы, но не переменные и классы.

    Не все методы в классе должны быть синхронизированы.

5.  Как работают методы wait(), notify() и notifyAll()?
    Методы должны вызываться на объекте-мониторе только из синхронизированного кода. Поток, который вызывает эти методы
    должен владеть монитором, иначе будет выдано исключение java.lang.IllegalMonitorStateException.


6.  В каких состояниях может находиться поток?
    Поток может быть в следующем состоянии: созданный, запущенный, блокированный, остановленный, в режиме ожидания,
    в режиме ожидания по времени (NEW, RUNNABLE, BLOCKED, TERMINATED, WAITING, TIMED_WAITING).

7.  Что такое семафор? Как он реализован в Java?
    Для управления доступом к ресурсу семафор использует счетчик, представляющий количество разрешений.
    Если значение счетчика больше нуля, то поток получает доступ к ресурсу, при этом счетчик уменьшается на единицу.
    После окончания работы с ресурсом поток освобождает семафор, и счетчик увеличивается на единицу.
    Если же счетчик равен нулю, то поток блокируется и ждет, пока не получит разрешение от семафора.

    Установить количество разрешений для доступа к ресурсу можно с помощью конструкторов класса Semaphore:

8.  Что обозначает ключевое слово volatile? Почему операции над volatile переменными не атомарны?
        Модификатор volatile накладывает некоторые дополнительные условия на чтение/запись переменной. Важно понять две
        вещи о volatile переменных:
        Операции чтения/записи volatile переменной являются атомарными.
        Результат операции записи значения в volatile переменную одним потоком, становится виден всем другим потокам,
        которые используют эту переменную для чтения из нее значения.


9.  Для чего нужны Atomic типы данных? Чем отличаются от volatile?
    volatile обеспечивает только видимость изменений, а классы Atomic* дают еще и атомарность изменений.
    Простой пример - вам нужно проинкрементить счетчик и вернуть значение. Если поле счетчика будет обычным volatile int -
     возможна ситуация, когда два разных потока сначала проведут инкремент, а потом оба заберут результат двух инкрементов.

    Если же взять AtomicInteger, будет гарантирована атомарность, и каждый поток получит правильный результат.

10. Что такое потоки демоны? Для чего они нужны? Как создать поток-демон?

    Потоками-демонами называются потоки, работающие в фоновом режиме для нашей программы.

    В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился,
    но еще выполняются порожденные им потоки, система будет ждать их завершения.
    Однако это правило не относится к особому виду потоков – демонам. Если завершился последний обычный поток процесса,
     и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится.
     Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.

11. Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию?

        JVM поддерживает алгоритм планирования, называемый упреждающим планированием с фиксированным приоритетом.
        Все потоки Java имеют приоритет, и JVM сначала обслуживает тот, у которого наивысший приоритет.

        Когда мы создаем поток, он наследует свой приоритет по умолчанию. Когда несколько потоков готовы к выполнению,
         JVM выбирает и выполняет выполняемый поток, который имеет наивысший приоритет. Если этот поток останавливается
         или становится недоступным для выполнения, будут выполняться потоки с более низким приоритетом.
         В случае, если два потока имеют одинаковый приоритет, JVM будет выполнять их в порядке FIFO.

12. Как работает Thread.join()? Для чего он нужен?
    Одна нить (поток) может вызвать метод join() у другой нити. В результате первый поток (который вызвал метод)
    приостанавливает свою работу и ждет окончания работы второго потока (у объекта которого был вызван метод join()).

13. Чем отличаются методы yield () и sleep()?
    Помещение модификатора volatile перед определением переменной заставляет принудительно всегда читать и писать
    значение только в обычную (медленную) память (а не кэшировать). Записывается как: private volatile boolean varName;

    Статический метод Thread.yield() заставляет процессор переключиться на обработку других потоков системы.
    Метод может быть полезным, например, когда поток ожидает наступления какого-либо события и необходимо чтобы
    проверка его наступления происходила как можно чаще. В этом случае можно поместить проверку события и метод
    Thread.yield() в цикл:


14. Как правильно остановить поток? Для чего нужны методы .stop(), .interrupt(), .interrupted(), .isInterrupted().
    В Java 8 нет метода, который бы принудительно останавливал поток. Никто не гарантирует, что нить можно остановить.
    Она может остановиться только сама. Java имеет встроенный механизм оповещения потока, который называется
    Interruption (прерывание, вмешательство).

    Класс Thread содержит в себе скрытое булево поле, которое называется флагом прерывания. Установить этот флаг
    можно вызвав метод interrupt() потока. Проверить же, установлен ли этот флаг, можно двумя способами.
    Первый способ — вызвать метод bool isInterrupted() объекта потока, второй — вызвать статический метод bool T
    hread.interrupted().
    Первый метод возвращает состояние флага прерывания и оставляет этот флаг нетронутым. Второй метод возвращает
    состояние флага и сбрасывает его. Заметьте что Thread.interrupted() — статический метод класса Thread, и его
     вызов возвращает значение флага прерывания того потока, из которого он был вызван. Поэтому этот метод вызывается
     только изнутри потока и позволяет потоку проверить своё состояние прерывания.

    У методов, приостанавливающих выполнение потока, таких как sleep(), wait() и join() есть одна особенность —
    если во время их выполнения будет вызван метод interrupt() этого потока, они, не дожидаясь конца времени ожидания,
    сгенерируют исключение InterruptedException.

15. Чем Runnable отличается от Callable?
    Различия Runnable и Callable? Оба интерфейса представляют задачи, которые предназначены для выполнения в отдельных
    нитях. Runnable существует ещё с JDK 1.0, а Callable был добавлен в JDK 1.5. Главное их различие заключается в том,
    что метод call () у Callable может возвращать значения и выбрасывать исключения, что невозможно в методе run () у
     Runnable.

16. Что такое FutureTask?
    FutureTask представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс
    предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса
    состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено,
    метод получения будет заблокирован, если вычисление ещё не завершено.

17. Что такое deadlock?
    Deadlock или взаимная блокировка — это ошибка, которая происходит когда процессы имеют циклическую зависимость от
    пары синхронизированных объектов.
    Deadlock — это программа, в которой все параллельные процессы ожидают друг друга. В этом состоянии программа никогда
    не восстановится без вмешательства извне.

18. Что такое livelock?
    Livelock – тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в
    зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются в зависимости
    друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток
    предотвращения deadlock.

19. Что такое race condition?
    Состояние гонки (англ. race condition), также конкуренция — ошибка проектирования многопоточной системы или
    приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.
     Своё название ошибка получила от похожей ошибки проектирования электронных схем (см. Гонки сигналов).

20. Что такое Фреймворк fork/join? Для чего он нужен?
    Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества
    многопроцессорной архитектуры современных компьютеров. Он разработан для выполнения задач, которые можно рекурсивно
    разбить на маленькие подзадачи, которые можно решать параллельно.

21. Что означает ключевое слово synchronized? Где и для чего может использоваться?
    Ключевое слово synchronized используется для предотвращения одновременного выполнения разными потоками одного и
    того же блока кода. Оно гарантирует, что, если вы получили блокировку (войдя в синхронизированный блок), данные,
    на которые наложена эта блокировка, обрабатываются в эксклюзивном режиме, поэтому операция может считаться атомарной.

22. Что является монитором у статического синхронизированного класса?
    Класс
23. Что является монитором у нестатического синхронизированного класса?
    Обьект
24. util. Concurrent поверхностно.
25. Stream API & ForkJoinPool Как связаны, что это такое.
